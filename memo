Next.js part2

작업폴더에 npx create-next-app@latest --experimental-app 치면 그 폴더의 하위폴더에 
새로운 프로젝트 생성됨, Next장인에다가 하면 되는거임

관계형 데이터베이스 : 데이터를 엑셀처럼 표에 저장함, 데이터 입출력 시 SQL이라는 언어를 
사용해야 하고 미리 스키마 정의(표만들기)도 해야 하고 데이터 중복저장을 피하기 위해 
정규화 해야 하고 여러가지 귀찮은 점들을 신경 써야 한다.

비관계형 데이터베이스는 자료를 조금 더 자유로운 형식으로 저장할 수 있고 SQL언어,
스키마 정의(표만들기), 정규화 이런것들이 필요가 대부분 필요가 없다.
분산처리를 기본적으로 잘해서 주로 SNS서비스처럼 많은 데이터 입출력이 필요할 때도 강점을 보인다.

MongoDb 초기세팅법 : 
DataBase Access메뉴에서 Db접속용 아이디, 비번을 생성함, 
역할을 atlas admin으로 설정(모든걸 다 할수 있는 권한)
Network Access메뉴에서 IP를 추가함, 스타벅스에서 코딩할 수도 있으니 allow access from anywhere 또는 0.0.0.0/0을 추가함
원래는 신뢰할 수 있는 ip만 추가하는 게 좋음


monngodb
database : 하나의 프로젝트
collection : 하나의 폴더와 유사 (collection 이라는 폴더 안에 document(하나의 메모자 파일 등)를 object자료형으로 저장)

mongoDb연결 : 
1. npm install mongodb
2. page.js에서 import { MongoClient } from "mongodb"
3. export default async function Home() 이렇게 home 함수 지정
5. util폴더에 database.js 파일 생성 후
import { MongoClient } from 'mongodb'
    const url = '커넥트 유얼 어플리케이션 DB접속URL~~'
    const options = { useNewUrlParser: true }
    let connectDB

    if (process.env.NODE_ENV === 'development') {
    if (!global._mongo) {
        global._mongo = new MongoClient(url, options).connect()
    }
    connectDB = global._mongo
    } else {
    connectDB = new MongoClient(url, options).connect()
    }
    export { connectDB } 자세한건 part2 2번째 강의




첨보는 프로그램 만들기 :
1. 프로그램에 필요한 기능 전부 정리
2. 쉬운 기능부터 하나씩 개발
첨보는세부기능만들기 : 
1. 어떤식으로 동작하는지 상세하게 한글로 설명. 
2. 코드로 치환

ex)게시판에 필요한 기능?
 - 글목록 조회기능 : 1. html페이지 필요 2. 페이지 방문하면 db에서 글 꺼내옴 3. 글들을 html에 꽂아 넣기
 - 상세페이지 : 
 - 글발행기능
 - 수정삭제기능

 상세페이지에 필요한 기능:
1. 글제목누르면 상세페이지 이동
2. 상세페이지 방문시 DB에서 글1개 꺼내서 html에 보여주기
dynamic route 쓰면 /detail/1 /detail/2처럼 여러의 폴더를 만들 필요가 없다.

 await이란? : 자바스크립트에서는 어떠한 코드가 실행이 오래 걸리면 다음 코드를 먼저 실행한다. 하지만 db를 가져오기 전에 다른 페이지를 로드해 버리면 이상해지기 때문에 await을 붙여서 db가 로드될 때까지 기다리는것이다.

 object 자료형 : 
 let data = { name : 'kim', age : 20 }

 const db = (await connectDB).db("forum")//db에접속
 let result = await db.collection('post').findOne({title : '안녕'})//title이 안녕인 것만 가져옴 근데 title이 중복이면 맨위에것만 가져오기 때문에 가져올때는 _id속성을 이용하는게 좋다. 


 useRoute를 이용한 링크변경 (클라이언트컴포넌드에서만 사용 가능한데 굳이 서버컴포넌트에서 사용하고싶으면 파이를 하나 따로 만들어서 컴포넌트 export, import후 서버컴포넌트에서 사용)
 1. router.push('/링크') : 해당 링크로 이동
 2. router.back() : 뒤로가기
 3. router.forward() : 앞으로가기
 4. router.refresh() : 바뀐내용만 새로고침
 5. router.prefetch('/detail/dsds') : 페이지 미리로드(엄청빠르게 로드) 
 근데사실 Link태그만 써도 prefetch기능이 자동으로 사용됨 다만 게시판같이 글들이 많은곳에서 페이지를 굳이 미리 로드를 할 필요가 없다. 이럴 땐 <Link prefetch={false}></Link> 를 사용하여 미리 prefecth기능을 끌 수 있다.
usePathname() : 현재url 출력
useSearchParams() : 현재 서치파라미터 출력



method의 종류 5가지 : GET(유저에게 데이터 전송), POST(새로운 데이터 추가), 
PUT(데이터 수정), DELETE(데이터 삭제), PATCH(데이터 수정)

next.js에서는 input태그의 value를 defalutvalue라고 사용해야 오류가 안난다.



게시판 기능 구현 CRUD

보여주기 기능 READ
1. 다이나믹 라우트에 입력한 주소에 들어갔을때
2. db에서 자료를 뽑아서
3. 화면에 보여줌
detail\page.js에서 데이터바인딩으로 보여주는중


글 발행 기능 CREATE
1. 글작성페이지 필요
2. 버튼누르면 서버에 글저장해달라고 부탁
3. 서버는 부탁받은 글을 검사해보고 DB에 저장
write\page.js에서 /api/post/new 로 POST요청을 보내면 서버에 object자료형으로 간다. 그 후 서버에서 insertOne으로 db에 삽입한다.



글 수정 기능 UPDATE
1. 글 수정페이지 필요 
2. db에서 result값을 뽑아서 input태그 안 defalutvalue에 적는다.
3. /api/post/edit으로 POST요청을 보낸다.
4. 서버에서는 ID속성이 같은 글을 찾아서 updateOne으로 수정한다.
    ++) result._id.toString()으로 문자화 시키는게 좋은 습관임
        updateOne 시 덮어쓰기 말고 증감시키고싶을때 $set대신에 $inc를 통해서 +1같이 증감시킬 수 있다.



글 삭제 기능 DELETE
1. list페이지에 삭제 버튼 하나 생성 
2. 폼태그를 이용해서 db값을 _id에 담아서 서버에 보냄
3. 서버는 받은 id의 글을 찾아서 deleteOne을 이용하여 삭제를 진행함
    ++)
    props를 사용할 때 ()안에 props 대신에 {result}를 사용하면 props 생략이 가능하다. ==디스트럭터링문법
    Ajax : fetch를 사용하면 form태그를 이용하지 않아도 서버에 요청을 보낼 수 있다. 폼태그를 사용하면 새로고침이 반드시 되는데 fetch는 새로고침 안해도 댐 

    fetch에서 url주소로 POST요청을 보낸다. 이때, body에 문자와 숫자를 담아서 보내는데 object나 array를 담으려면 JSON.stringify() 안에 담아서 서버에 보낸 후 서버 내에서 JSON.parse()로 파싱을 한 뒤에 deleteOne으로 db내의 자료를 삭제해야 한다.
    fetch쓸때 너무 코드가 길어서 axios를 사용하기도 한다.
                            fetch('/api/post/delete',{
                                method : "DELETE",
                                body :  props.result[i]._id
                            }).then((e)=>{
                                e.target.parentElement.style.opacity = 0
                            }).then((r)=>{
                                if(r.status == 200) {
                                  return r.json()
                                } else {
                                  //서버가 에러코드전송시 실행할코드
                                }
                            }).then((result)=>{ 
                            //성공시 실행할코드
                            }).catch((error)=>{
                            //인터넷문제 등으로 실패시 실행할코드
                            console.log(error)
                            })

서서히 사라지게 하는법 : opacity 1부터 0까지 주고 transitaion : all 1s 주면 댐


서버기능들을 멋진 말로 API라고 부름

query string : 서버에 fetch로 요청을 보낼 때 fetch('/api/test?name=kim&age=20') 이러한 형태의 요청을 query string 이라고 한다. 서버 내에서 요청.query 를 콘솔에 찍어보면 { name : 'kim', age : '20' }의 형태로 나온다.
장점 : 간단함, GET요청으로 데이터 전송 가능
단점 : 길어지면 더러워짐, url에 데이터가 노출이 됨

url파라미터 문법 : 누가 url주소 뒤에 /아무거나 입력해도 [어쩌구].js에서 처리를 해줌
누가 fetch('api/abc/kim')을 쓰면 [어쩌구].js에서 요청.query에 데이터가 찍힘 



기능구현을 다 했으면 성능 향상이 필요하다.
프로젝트 배포하려면 터미널 오픈 후에 npm run build(react문법을 html css js파일로 바꾸어 준다.)
그 후 npm run start하면 배포됨

*중요* rendering 방식 두가지
O 페이지는 static rendering 해줌(default)
npm run build 할때 만든 html 페이지 그대로 유저에게 보냄(기능은 없고 전송이 빠름)
다만/list페이지같이 계속 변해서 dynamic rendering을 사용해야하는데 O표시가 되어있는 경우가 있음. static rendering이면 list같이 html의 변경이 빈번한 페이지도 글 작성을 하거나 삭제를 해도 html상의 변경이 이루어지지 않음

ㅅ(람다)페이지는 dynamic rendering 해줌 (fetch쓰면 다이나믹 됨)
유저가 페이지 접속마다 html을 새로 만들어서 보내줌

 static rendering <-> dynamic rendering 바꾸는 법 : export const dynamic = 'force-dynamic'
 또는 export const dynamic = 'force-static' 을 list페이지에 컴포넌트 위에 선언한다.



 다이나믹 렌더링의 서버,db부담을 더는 법
 페이지 캐싱 : 잠깐 저장해두고 몰래 사용함
 글 발행을 해도 20초동안은 이미 저장해둔 값을 사용하기때문에 바로 변하지 않음
 ex) 같은 list, list2 를 만들고 하나는 다이나믹 렌더링, 하나는 revalidation을 사용하면 전자는 발행, 삭제가 진행되자마자 html상에서의 삭제도 진행된다. 후자는 새로고침을 해도 일정 시간동안은 이미 저장해둔 값을 사용하기 때문에 바로 변하지 않는다.



\
 캐싱 종류 : 
  await fetch('/URL', {cache : 'force-cache'})//유알엘에 데이터 요청시 마다 결과몰래 저장해두고 그걸 씀 (데이터절약, 속도상승)
  await fetch('/URL', {cache : 'no-store'})// 캐싱을 하지 않고 항상 새걸로 가져옴
  await fetch('/URL', {next : {revalidate : 60}}) // 60초동안만 저장하고 그 이후부터는 새걸 씀

 













